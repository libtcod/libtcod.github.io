<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-772NXFFJ4E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-772NXFFJ4E');
  </script>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>libtcod: TCODPath Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
  </script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">libtcod
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_t_c_o_d_path.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_t_c_o_d_path-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TCODPath Class Reference<div class="ingroups"><a class="el" href="group___pathfinding___c_p_p.html">Pathfinding (C++)</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="path_8hpp_source.html">path.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_c_o_d_path_1_1_wrapper_data.html">WrapperData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae05e2f3d2e93e399274f6e05d5ebd841"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#ae05e2f3d2e93e399274f6e05d5ebd841">TCODPath</a> (const <a class="el" href="class_t_c_o_d_map.html">TCODMap</a> *map, float diagonalCost=1.41f)</td></tr>
<tr class="memdesc:ae05e2f3d2e93e399274f6e05d5ebd841"><td class="mdescLeft">&#160;</td><td class="mdescRight">First, you have to allocate a path using a map from <a href="fov.html">the Field of view module</a>.  <a href="class_t_c_o_d_path.html#ae05e2f3d2e93e399274f6e05d5ebd841">More...</a><br /></td></tr>
<tr class="separator:ae05e2f3d2e93e399274f6e05d5ebd841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fbdb1f51f7daab0ad5b8857c00a04d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#ac1fbdb1f51f7daab0ad5b8857c00a04d">TCODPath</a> (int width, int height, const <a class="el" href="class_i_t_c_o_d_path_callback.html">ITCODPathCallback</a> *listener, void *userData, float diagonalCost=1.41f)</td></tr>
<tr class="memdesc:ac1fbdb1f51f7daab0ad5b8857c00a04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since the walkable status of a cell may depend on a lot of parameters (the creature type, the weather, the terrain type...), you can also create a path by providing a function rather than relying on a <a class="el" href="class_t_c_o_d_map.html">TCODMap</a>.  <a href="class_t_c_o_d_path.html#ac1fbdb1f51f7daab0ad5b8857c00a04d">More...</a><br /></td></tr>
<tr class="separator:ac1fbdb1f51f7daab0ad5b8857c00a04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43addf82ccd58110cdcde9abac9c3e8"><td class="memItemLeft" align="right" valign="top"><a id="af43addf82ccd58110cdcde9abac9c3e8" name="af43addf82ccd58110cdcde9abac9c3e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TCODPath</b> (const <a class="el" href="class_t_c_o_d_path.html">TCODPath</a> &amp;)=delete</td></tr>
<tr class="separator:af43addf82ccd58110cdcde9abac9c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1d299ae5fc231b5fcc518c83ce3f09"><td class="memItemLeft" align="right" valign="top"><a id="a8c1d299ae5fc231b5fcc518c83ce3f09" name="a8c1d299ae5fc231b5fcc518c83ce3f09"></a>
<a class="el" href="class_t_c_o_d_path.html">TCODPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_t_c_o_d_path.html">TCODPath</a> &amp;)=delete</td></tr>
<tr class="separator:a8c1d299ae5fc231b5fcc518c83ce3f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3310fa8753491458fa3ca9515ae454ba"><td class="memItemLeft" align="right" valign="top"><a id="a3310fa8753491458fa3ca9515ae454ba" name="a3310fa8753491458fa3ca9515ae454ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TCODPath</b> (<a class="el" href="class_t_c_o_d_path.html">TCODPath</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:a3310fa8753491458fa3ca9515ae454ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9ab772def65bca48b6bb8965b32114"><td class="memItemLeft" align="right" valign="top"><a id="aef9ab772def65bca48b6bb8965b32114" name="aef9ab772def65bca48b6bb8965b32114"></a>
<a class="el" href="class_t_c_o_d_path.html">TCODPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_t_c_o_d_path.html">TCODPath</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:aef9ab772def65bca48b6bb8965b32114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc271e34064a27685ee5b491a7a7ab7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#a5fc271e34064a27685ee5b491a7a7ab7">~TCODPath</a> ()</td></tr>
<tr class="memdesc:a5fc271e34064a27685ee5b491a7a7ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">To release the resources used by a path, destroy it with :<a class="el" href="class_t_c_o_d_path.html#a5fc271e34064a27685ee5b491a7a7ab7" title="To release the resources used by a path, destroy it with :TCODPath::~TCODPath() TCODDijkstra::~TCODDi...">TCODPath::~TCODPath()</a> TCODDijkstra::~TCODDijkstra()void TCOD_path_delete(TCOD_path_t path) void TCOD_dijkstra_delete(TCOD_dijkstra_t dijkstra)path_delete(path) dijkstra_delete(dijkstra)void TCODPath::Dispose() void TCODDijkstra::Dispose()  <a href="class_t_c_o_d_path.html#a5fc271e34064a27685ee5b491a7a7ab7">More...</a><br /></td></tr>
<tr class="separator:a5fc271e34064a27685ee5b491a7a7ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f824082c58ca1830fdfca2b72ce3b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#a42f824082c58ca1830fdfca2b72ce3b2">compute</a> (int ox, int oy, int dx, int dy)</td></tr>
<tr class="memdesc:a42f824082c58ca1830fdfca2b72ce3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once you created a <a class="el" href="class_t_c_o_d_path.html">TCODPath</a> object, you can compute the path between two points:  <a href="class_t_c_o_d_path.html#a42f824082c58ca1830fdfca2b72ce3b2">More...</a><br /></td></tr>
<tr class="separator:a42f824082c58ca1830fdfca2b72ce3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b1805f9fb6aeeb152b6bec1fd9ff8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#a93b1805f9fb6aeeb152b6bec1fd9ff8a">reverse</a> ()</td></tr>
<tr class="memdesc:a93b1805f9fb6aeeb152b6bec1fd9ff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once you computed a path, you can exchange origin and destination :void <a class="el" href="class_t_c_o_d_path.html#a93b1805f9fb6aeeb152b6bec1fd9ff8a" title="Once you computed a path, you can exchange origin and destination :void TCODPath::reverse() void TCOD...">TCODPath::reverse()</a> void TCODDijkstra::reverse()void TCOD_path_reverse(TCOD_path_t path) void TCOD_dijkstra_reverse(TCOD_dijkstra_t dijkstra)path_reverse(path) dijkstra_reverse(dijkstra)void <a class="el" href="class_t_c_o_d_path.html#a93b1805f9fb6aeeb152b6bec1fd9ff8a" title="Once you computed a path, you can exchange origin and destination :void TCODPath::reverse() void TCOD...">TCODPath::reverse()</a> void TCODDijkstra::reverse()  <a href="class_t_c_o_d_path.html#a93b1805f9fb6aeeb152b6bec1fd9ff8a">More...</a><br /></td></tr>
<tr class="separator:a93b1805f9fb6aeeb152b6bec1fd9ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac144ffb712e53bf7e087158302ef53f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#ac144ffb712e53bf7e087158302ef53f9">getOrigin</a> (int *x, int *y) const</td></tr>
<tr class="memdesc:ac144ffb712e53bf7e087158302ef53f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can read the current origin and destination cells with getOrigin/getDestination. Note that when you walk the path, the origin changes at each step.void <a class="el" href="class_t_c_o_d_path.html#ac144ffb712e53bf7e087158302ef53f9" title="You can read the current origin and destination cells with getOrigin/getDestination....">TCODPath::getOrigin(int *x,int *y) const</a> void TCODPath::getDestination(int *x,int *y) constvoid TCOD_path_get_origin(TCOD_path_t path, int *x, int *y) void TCOD_path_get_destination(TCOD_path_t path, int *x, int *y)path_get_origin(path) # returns x,y path_get_destination(path) # returns x,yvoid TCODPath::getOrigin(out int x, out int y) void TCODPath::getDestination(out int x, out int y)  <a href="class_t_c_o_d_path.html#ac144ffb712e53bf7e087158302ef53f9">More...</a><br /></td></tr>
<tr class="separator:ac144ffb712e53bf7e087158302ef53f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09f86e2004c90dc94fe90e538e2bfdb"><td class="memItemLeft" align="right" valign="top"><a id="ac09f86e2004c90dc94fe90e538e2bfdb" name="ac09f86e2004c90dc94fe90e538e2bfdb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getDestination</b> (int *x, int *y) const</td></tr>
<tr class="separator:ac09f86e2004c90dc94fe90e538e2bfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f19da87c0462555fdd5a420ec27929"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929">size</a> () const</td></tr>
<tr class="memdesc:a96f19da87c0462555fdd5a420ec27929"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can get the number of steps needed to reach destination :int <a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929" title="You can get the number of steps needed to reach destination :int TCODPath::size() const int TCODDijks...">TCODPath::size() const</a> int TCODDijkstra::size() constint TCOD_path_size(TCOD_path_t path) int TCOD_dijkstra_size(TCOD_dijkstra_t dijkstra)path_size(path) dijkstra_size(dijkstra)int <a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929" title="You can get the number of steps needed to reach destination :int TCODPath::size() const int TCODDijks...">TCODPath::size()</a> int TCODDijkstra::size()  <a href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929">More...</a><br /></td></tr>
<tr class="separator:a96f19da87c0462555fdd5a420ec27929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb0d57003d06c1e316585ce35d2556d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#a2fb0d57003d06c1e316585ce35d2556d">get</a> (int index, int *x, int *y) const</td></tr>
<tr class="memdesc:a2fb0d57003d06c1e316585ce35d2556d"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can get the coordinates of each point along the path :void <a class="el" href="class_t_c_o_d_path.html#a2fb0d57003d06c1e316585ce35d2556d" title="You can get the coordinates of each point along the path :void TCODPath::get(int index,...">TCODPath::get(int index, int *x, int *y) const</a> void TCODDijkstra::get(int index, int *x, int *y) constvoid TCOD_path_get(TCOD_path_t path, int index, int *x, int *y) void TCOD_dijkstra_get(TCOD_dijkstra_t dijkstra, int index, int *x, int *y)path_get(path, index) # returns x,y dijkstra_get(dijkstra, index) # returns x,yint <a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929" title="You can get the number of steps needed to reach destination :int TCODPath::size() const int TCODDijks...">TCODPath::size()</a> int TCODDijkstra::size()  <a href="class_t_c_o_d_path.html#a2fb0d57003d06c1e316585ce35d2556d">More...</a><br /></td></tr>
<tr class="separator:a2fb0d57003d06c1e316585ce35d2556d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae597ede1707cd98a162fdc0865b4b426"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#ae597ede1707cd98a162fdc0865b4b426">isEmpty</a> () const</td></tr>
<tr class="memdesc:ae597ede1707cd98a162fdc0865b4b426"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want a creature to follow the path, a more convenient way is to walk the path : You know when you reached destination when the path is empty :bool <a class="el" href="class_t_c_o_d_path.html#ae597ede1707cd98a162fdc0865b4b426" title="If you want a creature to follow the path, a more convenient way is to walk the path : You know when ...">TCODPath::isEmpty() const</a> bool TCODDijkstra::isEmpty() constbool TCOD_path_is_empty(TCOD_path_t path) bool TCOD_dijkstra_is_empty(TCOD_dijkstra_t dijkstra)path_is_empty(path) dijkstra_is_empty(dijkstra)bool <a class="el" href="class_t_c_o_d_path.html#ae597ede1707cd98a162fdc0865b4b426" title="If you want a creature to follow the path, a more convenient way is to walk the path : You know when ...">TCODPath::isEmpty()</a> bool TCODDijkstra::isEmpty()  <a href="class_t_c_o_d_path.html#ae597ede1707cd98a162fdc0865b4b426">More...</a><br /></td></tr>
<tr class="separator:ae597ede1707cd98a162fdc0865b4b426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad293b06a14a7e1c14a59fe19c3a946b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_path.html#aad293b06a14a7e1c14a59fe19c3a946b">walk</a> (int *x, int *y, bool recalculateWhenNeeded)</td></tr>
<tr class="memdesc:aad293b06a14a7e1c14a59fe19c3a946b"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can walk the path and go to the next step with : Note that walking the path consume one step (and decrease the path size by one).  <a href="class_t_c_o_d_path.html#aad293b06a14a7e1c14a59fe19c3a946b">More...</a><br /></td></tr>
<tr class="separator:aad293b06a14a7e1c14a59fe19c3a946b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adca11df1f540a308c7a29913c2537555"><td class="memItemLeft" align="right" valign="top"><a id="adca11df1f540a308c7a29913c2537555" name="adca11df1f540a308c7a29913c2537555"></a>
TCOD_path_t&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:adca11df1f540a308c7a29913c2537555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab290d1ff2ac8040f7fd2f8125e7513a4"><td class="memItemLeft" align="right" valign="top"><a id="ab290d1ff2ac8040f7fd2f8125e7513a4" name="ab290d1ff2ac8040f7fd2f8125e7513a4"></a>
struct <a class="el" href="struct_t_c_o_d_path_1_1_wrapper_data.html">TCODPath::WrapperData</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cppData</b></td></tr>
<tr class="separator:ab290d1ff2ac8040f7fd2f8125e7513a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abdf07d64be0ce068a30c24b72833bfd7"><td class="memItemLeft" align="right" valign="top"><a id="abdf07d64be0ce068a30c24b72833bfd7" name="abdf07d64be0ce068a30c24b72833bfd7"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>TCOD_path_func</b> (int xFrom, int yFrom, int xTo, int yTo, void *data)</td></tr>
<tr class="separator:abdf07d64be0ce068a30c24b72833bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This toolkit allows one to easily calculate the optimal path between two points in your dungeon by using either the <a href="http://en.wikipedia.org/wiki/A*">A* algorithm</a> or <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's algorithm</a>. Please note that the paths generated with the two algorithms may differ slightly. Due to how they're implemented, A* will usually prefer diagonal moves over orthogonal, while Dijkstra will have the opposite preference. In other words, paths from point X to point Y will look like this: </p><div class="code"><pre>
Dijkstra:      A*:
..........   ..........
.X........   .X*.......
..*.......   ...**.....
...*......   .....**...
....****Y.   .......*Y.
..........   ..........
</pre></div> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae05e2f3d2e93e399274f6e05d5ebd841" name="ae05e2f3d2e93e399274f6e05d5ebd841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05e2f3d2e93e399274f6e05d5ebd841">&#9670;&#160;</a></span>TCODPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TCODPath::TCODPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_c_o_d_map.html">TCODMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>diagonalCost</em> = <code>1.41f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First, you have to allocate a path using a map from <a href="fov.html">the Field of view module</a>. </p>
<p ><a class="el" href="class_t_c_o_d_path.html#ae05e2f3d2e93e399274f6e05d5ebd841" title="First, you have to allocate a path using a map from the Field of view module.">TCODPath::TCODPath</a>(const <a class="el" href="class_t_c_o_d_map.html">TCODMap</a> *map, float diagonalCost=1.41f) TCODDijkstra::TCODDijkstra(const <a class="el" href="class_t_c_o_d_map.html">TCODMap</a> *map, float diagonalCost=1.41f)</p>
<p >TCOD_path_t TCOD_path_new_using_map(TCOD_map_t map, float diagonalCost) TCOD_dijkstra_t TCOD_dijkstra_new(TCOD_map_t map, float diagonalCost)</p>
<p >path_new_using_map(map, diagonalCost=1.41) dijkstra_new(map, diagonalCost=1.41)</p>
<p ><a class="el" href="class_t_c_o_d_path.html">TCODPath(TCODMap map, float diagonalCost)</a> <a class="el" href="class_t_c_o_d_path.html">TCODPath(TCODMap map)</a> <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra(TCODMap map, float diagonalCost)</a> <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra(TCODMap map)</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map. The path finder will use the 'walkable' property of the cells to find a path. </td></tr>
    <tr><td class="paramname">diagonalCost</td><td>Cost of a diagonal movement compared to an horizontal or vertical movement. On a standard cartesian map, it should be sqrt(2) (1.41f). It you want the same cost for all movements, use 1.0f. If you don't want the path finder to use diagonal movements, use 0.0f.</td></tr>
  </table>
  </dd>
</dl>
<p>A* : <a class="el" href="class_t_c_o_d_map.html">TCODMap</a> *myMap = new <a class="el" href="class_t_c_o_d_map.html">TCODMap(50,50)</a>; <a class="el" href="class_t_c_o_d_path.html">TCODPath</a> *path = new <a class="el" href="class_t_c_o_d_path.html">TCODPath(myMap)</a>; // allocate the path Dijkstra: <a class="el" href="class_t_c_o_d_map.html">TCODMap</a> *myMap = new <a class="el" href="class_t_c_o_d_map.html">TCODMap(50,50)</a>; <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra</a> *dijkstra = new <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra(myMap)</a>; // allocate the path</p>
<p >A* : TCOD_map_t my_map=TCOD_map_new(50,50,true); TCOD_path_t path = TCOD_path_new_using_map(my_map,1.41f); Dijkstra : TCOD_map_t my_map=TCOD_map_new(50,50,true); TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new(my_map,1.41f);</p>
<h1><a class="anchor" id="autotoc_md42"></a>
A* :</h1>
<p >my_map=libtcod.map_new(50,50,True) path = libtcod.path_new_using_map(my_map) </p>
<h1><a class="anchor" id="autotoc_md43"></a>
Dijkstra</h1>
<p >my_map=libtcod.map_new(50,50,True) dijkstra = libtcod.dijkstra_new(my_map) </p>

</div>
</div>
<a id="ac1fbdb1f51f7daab0ad5b8857c00a04d" name="ac1fbdb1f51f7daab0ad5b8857c00a04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fbdb1f51f7daab0ad5b8857c00a04d">&#9670;&#160;</a></span>TCODPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TCODPath::TCODPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_t_c_o_d_path_callback.html">ITCODPathCallback</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>diagonalCost</em> = <code>1.41f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Since the walkable status of a cell may depend on a lot of parameters (the creature type, the weather, the terrain type...), you can also create a path by providing a function rather than relying on a <a class="el" href="class_t_c_o_d_map.html">TCODMap</a>. </p>
<p >Callback : class <a class="el" href="class_i_t_c_o_d_path_callback.html" title="Callback class for defining pathfinding graph edges.">ITCODPathCallback</a> { public: virtual float getWalkCost( int xFrom, int yFrom, int xTo, int yTo, void &lt;em&gt;userData ) const = 0; }; A constructor: <a class="el" href="class_t_c_o_d_path.html#ae05e2f3d2e93e399274f6e05d5ebd841" title="First, you have to allocate a path using a map from the Field of view module.">TCODPath::TCODPath</a>(int width, int height, const <a class="el" href="class_i_t_c_o_d_path_callback.html" title="Callback class for defining pathfinding graph edges.">ITCODPathCallback</a> *callback, void *userData, float diagonalCost=1.41f) Dijkstra constructor TCODDijkstra::TCODDijkstra(int width, int height, const <a class="el" href="class_i_t_c_o_d_path_callback.html" title="Callback class for defining pathfinding graph edges.">ITCODPathCallback</a> *callback, void *userData, float diagonalCost=1.41f)</p>
<p >typedef float (*TCOD_path_func_t)( int xFrom, int yFrom, int xTo, int yTo, void *user_data ) TCOD_path_t TCOD_path_new_using_function(int width, int height, TCOD_path_func_t callback, void *user_data, float diagonalCost) TCOD_dijkstra_t TCOD_dijkstra_new_using_function(int width, int height, TCOD_path_func_t callback, void *user_data, float diagonalCost)</p>
<p >def path_func(xFrom,yFrom,xTo,yTo,userData) : ... path_new_using_function(width, height, path_func, user_data=0, diagonalCost=1.41) dijkstra_new_using_function(width, height, path_func, user_data=0, diagonalCost=1.41)</p>
<p ><a class="el" href="class_t_c_o_d_path.html">TCODPath(int width, int height, ITCODPathCallback listener, float diagonalCost)</a> <a class="el" href="class_t_c_o_d_path.html">TCODPath(int width, int height, ITCODPathCallback listener)</a> <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra(int width, int height, ITCODPathCallback listener, float diagonalCost)</a> <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra(int width, int height, ITCODPathCallback listener)</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width,height</td><td>The size of the map (in map cells). </td></tr>
    <tr><td class="paramname">callback</td><td>A custom function that must return the walk cost from coordinates xFrom,yFrom to coordinates xTo,yTo. The cost must be &gt; 0.0f if the cell xTo,yTo is walkable. It must be equal to 0.0f if it's not. You must not take additional cost due to diagonal movements into account as it's already done by the pathfinder. </td></tr>
    <tr><td class="paramname">userData</td><td>Custom data that will be passed to the function. </td></tr>
    <tr><td class="paramname">diagonalCost</td><td>Cost of a diagonal movement compared to an horizontal or vertical movement. On a standard cartesian map, it should be sqrt(2) (1.41f). It you want the same cost for all movements, use 1.0f. If you don't want the path finder to use diagonal movements, use 0.0f.</td></tr>
  </table>
  </dd>
</dl>
<p>class MyCallback : public <a class="el" href="class_i_t_c_o_d_path_callback.html" title="Callback class for defining pathfinding graph edges.">ITCODPathCallback</a> { public : float getWalkCost(int xFrom, int yFrom, int xTo, int yTo, void *userData ) const { ... } }; <a class="el" href="class_t_c_o_d_path.html">TCODPath</a> *path = new <a class="el" href="class_t_c_o_d_path.html">TCODPath(50,50,new MyCallback(),NULL)</a>; // allocate the path <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra</a> *dijkstra = new <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra(50,50,new MyCallback(),NULL)</a>; // allocate Dijkstra</p>
<p >float my_func(int xFrom, int yFrom, int xTo, int yTo, void *user_data) { ... } TCOD_path_t path = TCOD_path_new_using_function(50,50,my_func,NULL,1.41f); TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new_using_function(50,50,my_func,NULL,1.41f);</p>
<p >def my_func(xFrom, yFrom, xTo, yTo, user_data) : </p>
<h1><a class="anchor" id="autotoc_md44"></a>
return a float cost for this movement</h1>
<p >return 1.0 path = libtcod.path_new_using_function(50,50,my_func) dijkstra = libtcod.dijkstra_new_using_function(50,50,my_func) </p>

</div>
</div>
<a id="a5fc271e34064a27685ee5b491a7a7ab7" name="a5fc271e34064a27685ee5b491a7a7ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc271e34064a27685ee5b491a7a7ab7">&#9670;&#160;</a></span>~TCODPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TCODPath::~TCODPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To release the resources used by a path, destroy it with :<a class="el" href="class_t_c_o_d_path.html#a5fc271e34064a27685ee5b491a7a7ab7" title="To release the resources used by a path, destroy it with :TCODPath::~TCODPath() TCODDijkstra::~TCODDi...">TCODPath::~TCODPath()</a> TCODDijkstra::~TCODDijkstra()void TCOD_path_delete(TCOD_path_t path) void TCOD_dijkstra_delete(TCOD_dijkstra_t dijkstra)path_delete(path) dijkstra_delete(dijkstra)void TCODPath::Dispose() void TCODDijkstra::Dispose() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>In the C version, the path handler returned by one of the TCOD_path_new_* function. </td></tr>
    <tr><td class="paramname">dijkstra</td><td>In the C version, the path handler returned by one of the TCOD_dijkstra_new* function.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_t_c_o_d_path.html">TCODPath</a> *path = new <a class="el" href="class_t_c_o_d_path.html">TCODPath(myMap)</a>; // allocate the path use the path... delete path; // destroy the path</p>
<p ><a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra</a> *dijkstra = new <a class="el" href="class_t_c_o_d_dijkstra.html">TCODDijkstra(myMap)</a>; // allocate the path use the path... delete dijkstra; // destroy the path</p>
<p >TCOD_path_t path = TCOD_path_new_using_map(my_map); use the path ... TCOD_path_delete(path);</p>
<p >TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new(my_map); use the path ... TCOD_dijkstra_delete(dijkstra);</p>
<p >path = libtcod.path_new_using_map(my_map) </p>
<h1><a class="anchor" id="autotoc_md45"></a>
use the path ...</h1>
<p >libtcod.path_delete(path)</p>
<p >dijkstra = libtcod.dijkstra_new(my_map) </p>
<h1><a class="anchor" id="autotoc_md46"></a>
use the path ...</h1>
<p >libtcod.dijkstra_delete(dijkstra) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a42f824082c58ca1830fdfca2b72ce3b2" name="a42f824082c58ca1830fdfca2b72ce3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f824082c58ca1830fdfca2b72ce3b2">&#9670;&#160;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCODPath::compute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once you created a <a class="el" href="class_t_c_o_d_path.html">TCODPath</a> object, you can compute the path between two points: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>In the C version, the path handler returned by a creation function. </td></tr>
    <tr><td class="paramname">ox,oy</td><td>Coordinates of the origin of the path. </td></tr>
    <tr><td class="paramname">dx,dy</td><td>Coordinates of the destination of the path. Both points should be inside the map, and at a walkable position. The function returns false if there is no possible path.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_t_c_o_d_map.html">TCODMap</a> *myMap = new <a class="el" href="class_t_c_o_d_map.html">TCODMap(50,50)</a>; <a class="el" href="class_t_c_o_d_path.html">TCODPath</a> *path = new <a class="el" href="class_t_c_o_d_path.html">TCODPath(myMap)</a>; // allocate the path path-&gt;compute(5,5,25,25); // calculate path from 5,5 to 25,25</p>
<p >TCOD_map_t my_map=TCOD_map_new(50,50); TCOD_path_t path = TCOD_path_new_using_map(my_map); TCOD_path_compute(path,5,5,25,25);</p>
<p >my_map=libtcod.map_new(50,50) path = libtcod.path_new_using_map(my_map) libtcod.path_compute(path,5,5,25,25) </p>

</div>
</div>
<a id="a2fb0d57003d06c1e316585ce35d2556d" name="a2fb0d57003d06c1e316585ce35d2556d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb0d57003d06c1e316585ce35d2556d">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCODPath::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can get the coordinates of each point along the path :void <a class="el" href="class_t_c_o_d_path.html#a2fb0d57003d06c1e316585ce35d2556d" title="You can get the coordinates of each point along the path :void TCODPath::get(int index,...">TCODPath::get(int index, int *x, int *y) const</a> void TCODDijkstra::get(int index, int *x, int *y) constvoid TCOD_path_get(TCOD_path_t path, int index, int *x, int *y) void TCOD_dijkstra_get(TCOD_dijkstra_t dijkstra, int index, int *x, int *y)path_get(path, index) # returns x,y dijkstra_get(dijkstra, index) # returns x,yint <a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929" title="You can get the number of steps needed to reach destination :int TCODPath::size() const int TCODDijks...">TCODPath::size()</a> int TCODDijkstra::size() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path,dijkstra</td><td>In the C version, the path handler returned by a creation function. </td></tr>
    <tr><td class="paramname">index</td><td>Step number. 0 &lt;= index &lt; path size </td></tr>
    <tr><td class="paramname">x,y</td><td>Address of the variables receiving the coordinates of the point.</td></tr>
  </table>
  </dd>
</dl>
<p>for (int i=0; i &lt; path-&gt;<a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929" title="You can get the number of steps needed to reach destination :int TCODPath::size() const int TCODDijks...">size()</a>; i++ ) { int x,y; path-&gt;get(i,&amp;x,&amp;y); printf ("Astar coord : %d %d\n", x,y ); } for (int i=0; i &lt; dijkstra-&gt;<a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929" title="You can get the number of steps needed to reach destination :int TCODPath::size() const int TCODDijks...">size()</a>; i++ ) { int x,y; dijkstra-&gt;get(i,&amp;x,&amp;y); printf ("Dijkstra coord : %d %d\n", x,y ); }</p>
<p >int i; for (i=0; i &lt; TCOD_path_size(path); i++ ) { int x,y; TCOD_path_get(path,i,&amp;x,&amp;y); printf ("Astar coord : %d %d\n", x,y ); } for (i=0; i &lt; TCOD_dijkstra_size(dijkstra); i++ ) { int x,y; TCOD_dijkstra_get(dijkstra,i,&amp;x,&amp;y); printf ("Dijkstra coord : %d %d\n", x,y ); }</p>
<p >for i in range (libtcod.path_size(path)) : x,y=libtcod.path_get(path,i) print 'Astar coord : ',x,y for i in range (libtcod.dijkstra_size(dijkstra)) : x,y=libtcod.dijkstra_get(dijkstra,i) print 'Dijkstra coord : ',x,y </p>

</div>
</div>
<a id="ac144ffb712e53bf7e087158302ef53f9" name="ac144ffb712e53bf7e087158302ef53f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac144ffb712e53bf7e087158302ef53f9">&#9670;&#160;</a></span>getOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCODPath::getOrigin </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can read the current origin and destination cells with getOrigin/getDestination. Note that when you walk the path, the origin changes at each step.void <a class="el" href="class_t_c_o_d_path.html#ac144ffb712e53bf7e087158302ef53f9" title="You can read the current origin and destination cells with getOrigin/getDestination....">TCODPath::getOrigin(int *x,int *y) const</a> void TCODPath::getDestination(int *x,int *y) constvoid TCOD_path_get_origin(TCOD_path_t path, int *x, int *y) void TCOD_path_get_destination(TCOD_path_t path, int *x, int *y)path_get_origin(path) # returns x,y path_get_destination(path) # returns x,yvoid TCODPath::getOrigin(out int x, out int y) void TCODPath::getDestination(out int x, out int y) </p>
<p >Once the path has been computed, you can get information about it using of one those functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>In the C version, the path handler returned by a creation function. </td></tr>
    <tr><td class="paramname">x,y</td><td>The function returns the cell coordinates in these variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae597ede1707cd98a162fdc0865b4b426" name="ae597ede1707cd98a162fdc0865b4b426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae597ede1707cd98a162fdc0865b4b426">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCODPath::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you want a creature to follow the path, a more convenient way is to walk the path : You know when you reached destination when the path is empty :bool <a class="el" href="class_t_c_o_d_path.html#ae597ede1707cd98a162fdc0865b4b426" title="If you want a creature to follow the path, a more convenient way is to walk the path : You know when ...">TCODPath::isEmpty() const</a> bool TCODDijkstra::isEmpty() constbool TCOD_path_is_empty(TCOD_path_t path) bool TCOD_dijkstra_is_empty(TCOD_dijkstra_t dijkstra)path_is_empty(path) dijkstra_is_empty(dijkstra)bool <a class="el" href="class_t_c_o_d_path.html#ae597ede1707cd98a162fdc0865b4b426" title="If you want a creature to follow the path, a more convenient way is to walk the path : You know when ...">TCODPath::isEmpty()</a> bool TCODDijkstra::isEmpty() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path,dijkstra</td><td>In the C version, the path handler returned by a creation function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93b1805f9fb6aeeb152b6bec1fd9ff8a" name="a93b1805f9fb6aeeb152b6bec1fd9ff8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b1805f9fb6aeeb152b6bec1fd9ff8a">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCODPath::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once you computed a path, you can exchange origin and destination :void <a class="el" href="class_t_c_o_d_path.html#a93b1805f9fb6aeeb152b6bec1fd9ff8a" title="Once you computed a path, you can exchange origin and destination :void TCODPath::reverse() void TCOD...">TCODPath::reverse()</a> void TCODDijkstra::reverse()void TCOD_path_reverse(TCOD_path_t path) void TCOD_dijkstra_reverse(TCOD_dijkstra_t dijkstra)path_reverse(path) dijkstra_reverse(dijkstra)void <a class="el" href="class_t_c_o_d_path.html#a93b1805f9fb6aeeb152b6bec1fd9ff8a" title="Once you computed a path, you can exchange origin and destination :void TCODPath::reverse() void TCOD...">TCODPath::reverse()</a> void TCODDijkstra::reverse() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>In the C version, the path handler returned by a creation function.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_t_c_o_d_map.html">TCODMap</a> *myMap = new <a class="el" href="class_t_c_o_d_map.html">TCODMap(50,50)</a>; <a class="el" href="class_t_c_o_d_path.html">TCODPath</a> *path = new <a class="el" href="class_t_c_o_d_path.html">TCODPath(myMap)</a>; // allocate the path path-&gt;compute(5,5,25,25); // calculate path from 5,5 to 25,25 path-&gt;<a class="el" href="class_t_c_o_d_path.html#a93b1805f9fb6aeeb152b6bec1fd9ff8a" title="Once you computed a path, you can exchange origin and destination :void TCODPath::reverse() void TCOD...">reverse()</a>; // now the path goes from 25,25 to 5,5</p>
<p >TCOD_map_t my_map=TCOD_map_new(50,50); TCOD_path_t path = TCOD_path_new_using_map(my_map); TCOD_path_compute(path,5,5,25,25); // calculate path from 5,5 to 25,25 TCOD_path_reverse(path); // now the path goes from 25,25 to 5,5</p>
<p >my_map=libtcod.map_new(50,50) path = libtcod.path_new_using_map(my_map) libtcod.path_compute(path,5,5,25,25) # calculate path from 5,5 to 25,25 libtcod.path_reverse(path) # now the path goes from 25,25 to 5,5 </p>

</div>
</div>
<a id="a96f19da87c0462555fdd5a420ec27929" name="a96f19da87c0462555fdd5a420ec27929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f19da87c0462555fdd5a420ec27929">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TCODPath::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can get the number of steps needed to reach destination :int <a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929" title="You can get the number of steps needed to reach destination :int TCODPath::size() const int TCODDijks...">TCODPath::size() const</a> int TCODDijkstra::size() constint TCOD_path_size(TCOD_path_t path) int TCOD_dijkstra_size(TCOD_dijkstra_t dijkstra)path_size(path) dijkstra_size(dijkstra)int <a class="el" href="class_t_c_o_d_path.html#a96f19da87c0462555fdd5a420ec27929" title="You can get the number of steps needed to reach destination :int TCODPath::size() const int TCODDijks...">TCODPath::size()</a> int TCODDijkstra::size() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path,dijkstra</td><td>In the C version, the path handler returned by a creation function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad293b06a14a7e1c14a59fe19c3a946b" name="aad293b06a14a7e1c14a59fe19c3a946b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad293b06a14a7e1c14a59fe19c3a946b">&#9670;&#160;</a></span>walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCODPath::walk </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recalculateWhenNeeded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can walk the path and go to the next step with : Note that walking the path consume one step (and decrease the path size by one). </p>
<p >The function returns false if recalculateWhenNeeded is false and the next cell on the path is no longer walkable, or if recalculateWhenNeeded is true, the next cell on the path is no longer walkable and no other path has been found. Also note that recalculateWhenNeeded only applies to A*.</p>
<p >bool <a class="el" href="class_t_c_o_d_path.html#aad293b06a14a7e1c14a59fe19c3a946b" title="You can walk the path and go to the next step with : Note that walking the path consume one step (and...">TCODPath::walk(int *x, int *y, bool recalculateWhenNeeded)</a> bool TCODDijkstra::walk(int *x, int *y)</p>
<p >bool TCOD_path_walk(TCOD_path_t path, int *x, int *y, bool recalculate_when_needed) bool TCOD_dijkstra_walk(TCOD_dijkstra_t dijkstra, int *x, int *y)</p>
<p >path_walk(TCOD_path_t path, recalculate_when_needed) # returns x,y or None,None if no path dijkstra_walk(TCOD_dijkstra_t dijkstra)</p>
<p >bool TCODPath::walk(ref int x, ref int y, bool recalculateWhenNeeded) bool TCODDijkstra::walk(ref int x, ref int y) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path,dijkstra</td><td>In the C version, the path handler returned by a creation function. </td></tr>
    <tr><td class="paramname">x,y</td><td>Address of the variables receiving the coordinates of the next point. </td></tr>
    <tr><td class="paramname">recalculateWhenNeeded</td><td>If the next point is no longer walkable (another creature may be in the way), recalculate a new path and walk it.</td></tr>
  </table>
  </dd>
</dl>
<p>while (! path-&gt;<a class="el" href="class_t_c_o_d_path.html#ae597ede1707cd98a162fdc0865b4b426" title="If you want a creature to follow the path, a more convenient way is to walk the path : You know when ...">isEmpty()</a>) { int x,y; if (path-&gt;walk(&amp;x,&amp;y,true)) { printf ("Astar coord: %d %d\n",x,y ); } else { printf ("I'm stuck!\n" ); break; } } while (! dijkstra-&gt;<a class="el" href="class_t_c_o_d_path.html#ae597ede1707cd98a162fdc0865b4b426" title="If you want a creature to follow the path, a more convenient way is to walk the path : You know when ...">isEmpty()</a>) { int x,y; if (dijkstra-&gt;walk(&amp;x,&amp;y)) { printf ("Dijkstra coord: %d %d\n",x,y ); } else { printf ("I'm stuck!\n" ); break; } }</p>
<p >while (! TCOD_path_is_empty(path)) { int x,y; if (TCOD_path_walk(path,&amp;x,&amp;y,true)) { printf ("Astar coord: %d %d\n",x,y ); } else { printf ("I'm stuck!\n" ); break; } } while (! TCOD_dijkstra_is_empty(dijkstra)) { int x,y; if (TCOD_dijkstra_walk(dijkstra,&amp;x,&amp;y)) { printf ("Dijkstra coord: %d %d\n",x,y ); } else { printf ("I'm stuck!\n" ); break; } }</p>
<p >while not libtcod.path_is_empty(path)) : x,y=libtcod.path_walk(path,True) if not x is None : print 'Astar coord: ',x,y else : print "I'm stuck!" break while not libtcod.dijkstra_is_empty(dijkstra)) : x,y=libtcod.dijkstra_walk(dijkstra,True) if not x is None : print 'Dijkstra coord: ',x,y else : print "I'm stuck!" break </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/4b796/Projects/libtcod/src/libtcod/<a class="el" href="path_8hpp_source.html">path.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_c_o_d_path.html">TCODPath</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
