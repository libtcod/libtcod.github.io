<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-772NXFFJ4E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-772NXFFJ4E');
  </script>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>libtcod: TCODBsp Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
  </script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">libtcod
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_t_c_o_d_bsp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_t_c_o_d_bsp-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TCODBsp Class Reference<div class="ingroups"><a class="el" href="group___b_s_p.html">Binary space partitioning</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bsp_8hpp_source.html">bsp.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TCODBsp:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_t_c_o_d_bsp.png" usemap="#TCODBsp_map" alt=""/>
  <map id="TCODBsp_map" name="TCODBsp_map">
<area href="class_t_c_o_d_tree.html" alt="TCODTree" shape="rect" coords="0,0,73,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d9dd6efec6193d43067f3e054e39ab3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#a3d9dd6efec6193d43067f3e054e39ab3">TCODBsp</a> ()</td></tr>
<tr class="memdesc:a3d9dd6efec6193d43067f3e054e39ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">First, you have to create the root node of the tree.  <a href="class_t_c_o_d_bsp.html#a3d9dd6efec6193d43067f3e054e39ab3">More...</a><br /></td></tr>
<tr class="separator:a3d9dd6efec6193d43067f3e054e39ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79f69ac2cfa06fe10ccaac653e9037f"><td class="memItemLeft" align="right" valign="top"><a id="ab79f69ac2cfa06fe10ccaac653e9037f" name="ab79f69ac2cfa06fe10ccaac653e9037f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TCODBsp</b> (int x, int y, int w, int h)</td></tr>
<tr class="separator:ab79f69ac2cfa06fe10ccaac653e9037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a73272e7df1aafbb0a8d63cc16c805f"><td class="memItemLeft" align="right" valign="top"><a id="a7a73272e7df1aafbb0a8d63cc16c805f" name="a7a73272e7df1aafbb0a8d63cc16c805f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TCODBsp</b> (const <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> &amp;)=delete</td></tr>
<tr class="separator:a7a73272e7df1aafbb0a8d63cc16c805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f7f462cac89715fedc3ecb32e775ca"><td class="memItemLeft" align="right" valign="top"><a id="a54f7f462cac89715fedc3ecb32e775ca" name="a54f7f462cac89715fedc3ecb32e775ca"></a>
<a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> &amp;)=delete</td></tr>
<tr class="separator:a54f7f462cac89715fedc3ecb32e775ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201c8859f55e3ca2cc4f7eb9e4d07e4b"><td class="memItemLeft" align="right" valign="top"><a id="a201c8859f55e3ca2cc4f7eb9e4d07e4b" name="a201c8859f55e3ca2cc4f7eb9e4d07e4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TCODBsp</b> (<a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:a201c8859f55e3ca2cc4f7eb9e4d07e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b197ca6d3ded48914328df50b122da"><td class="memItemLeft" align="right" valign="top"><a id="a81b197ca6d3ded48914328df50b122da" name="a81b197ca6d3ded48914328df50b122da"></a>
<a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:a81b197ca6d3ded48914328df50b122da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8942e17837013284425a0616ae04ad76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#a8942e17837013284425a0616ae04ad76">removeSons</a> ()</td></tr>
<tr class="memdesc:a8942e17837013284425a0616ae04ad76"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can delete a part of the tree, releasing resources for all sub nodes with :  <a href="class_t_c_o_d_bsp.html#a8942e17837013284425a0616ae04ad76">More...</a><br /></td></tr>
<tr class="separator:a8942e17837013284425a0616ae04ad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620f60223047a5a1f36f976af90bc863"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#a620f60223047a5a1f36f976af90bc863">~TCODBsp</a> ()</td></tr>
<tr class="memdesc:a620f60223047a5a1f36f976af90bc863"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can also completely delete the tree, including the root node to release every resource used :  <a href="class_t_c_o_d_bsp.html#a620f60223047a5a1f36f976af90bc863">More...</a><br /></td></tr>
<tr class="separator:a620f60223047a5a1f36f976af90bc863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6221bf79a1d0aa2275fa2e04b751b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#a6b6221bf79a1d0aa2275fa2e04b751b1">splitOnce</a> (bool horizontal, int position)</td></tr>
<tr class="memdesc:a6b6221bf79a1d0aa2275fa2e04b751b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once you have the root node, you can split it into two smaller non-overlapping nodes.  <a href="class_t_c_o_d_bsp.html#a6b6221bf79a1d0aa2275fa2e04b751b1">More...</a><br /></td></tr>
<tr class="separator:a6b6221bf79a1d0aa2275fa2e04b751b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45a60808aa2f17d138cb10744b65ab2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#ac45a60808aa2f17d138cb10744b65ab2">splitRecursive</a> (<a class="el" href="class_t_c_o_d_random.html">TCODRandom</a> *randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)</td></tr>
<tr class="memdesc:ac45a60808aa2f17d138cb10744b65ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can also recursively split the bsp.  <a href="class_t_c_o_d_bsp.html#ac45a60808aa2f17d138cb10744b65ab2">More...</a><br /></td></tr>
<tr class="separator:ac45a60808aa2f17d138cb10744b65ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1a2884ecf106f784f98a4525c65f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#a4e1a2884ecf106f784f98a4525c65f08">resize</a> (int x, int y, int w, int h)</td></tr>
<tr class="memdesc:a4e1a2884ecf106f784f98a4525c65f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operation resets the size of the tree nodes without changing the splitting data (orientation/position).  <a href="class_t_c_o_d_bsp.html#a4e1a2884ecf106f784f98a4525c65f08">More...</a><br /></td></tr>
<tr class="separator:a4e1a2884ecf106f784f98a4525c65f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934a1ad8d407a365c93ecb21c4161f32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#a934a1ad8d407a365c93ecb21c4161f32">getLeft</a> () const</td></tr>
<tr class="memdesc:a934a1ad8d407a365c93ecb21c4161f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once you have built a BSP tree, you can retrieve information from any node.  <a href="class_t_c_o_d_bsp.html#a934a1ad8d407a365c93ecb21c4161f32">More...</a><br /></td></tr>
<tr class="separator:a934a1ad8d407a365c93ecb21c4161f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aeb849b22ba9a5a5ab6e3e50677835"><td class="memItemLeft" align="right" valign="top"><a id="a90aeb849b22ba9a5a5ab6e3e50677835" name="a90aeb849b22ba9a5a5ab6e3e50677835"></a>
<a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRight</b> () const</td></tr>
<tr class="separator:a90aeb849b22ba9a5a5ab6e3e50677835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9db8bbda8382979d639a6fb130d8bd"><td class="memItemLeft" align="right" valign="top"><a id="a3f9db8bbda8382979d639a6fb130d8bd" name="a3f9db8bbda8382979d639a6fb130d8bd"></a>
<a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getFather</b> () const</td></tr>
<tr class="separator:a3f9db8bbda8382979d639a6fb130d8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4f880bbc5b70b7fade114deb6c05be"><td class="memItemLeft" align="right" valign="top"><a id="a6f4f880bbc5b70b7fade114deb6c05be" name="a6f4f880bbc5b70b7fade114deb6c05be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isLeaf</b> () const</td></tr>
<tr class="memdesc:a6f4f880bbc5b70b7fade114deb6c05be"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can know if a node is a leaf (not split, no sons) with this function : <br /></td></tr>
<tr class="separator:a6f4f880bbc5b70b7fade114deb6c05be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1360cc43a7d5cd21a0bcacbfa119f89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#af1360cc43a7d5cd21a0bcacbfa119f89">contains</a> (int x, int y) const</td></tr>
<tr class="memdesc:af1360cc43a7d5cd21a0bcacbfa119f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can check if a map cell is inside a node.  <a href="class_t_c_o_d_bsp.html#af1360cc43a7d5cd21a0bcacbfa119f89">More...</a><br /></td></tr>
<tr class="separator:af1360cc43a7d5cd21a0bcacbfa119f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25504bfc4750a5b3a1e9dd9cdb0e0b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#a25504bfc4750a5b3a1e9dd9cdb0e0b58">findNode</a> (int x, int y)</td></tr>
<tr class="memdesc:a25504bfc4750a5b3a1e9dd9cdb0e0b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can search the tree for the smallest node containing a map cell.  <a href="class_t_c_o_d_bsp.html#a25504bfc4750a5b3a1e9dd9cdb0e0b58">More...</a><br /></td></tr>
<tr class="separator:a25504bfc4750a5b3a1e9dd9cdb0e0b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781ae46ca99abb56b9e5d0a6bc4113ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_o_d_bsp.html#a781ae46ca99abb56b9e5d0a6bc4113ca">traversePreOrder</a> (<a class="el" href="class_i_t_c_o_d_bsp_callback.html">ITCODBspCallback</a> *listener, void *userData)</td></tr>
<tr class="memdesc:a781ae46ca99abb56b9e5d0a6bc4113ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can scan all the nodes of the tree and have a custom function called back for each node.  <a href="class_t_c_o_d_bsp.html#a781ae46ca99abb56b9e5d0a6bc4113ca">More...</a><br /></td></tr>
<tr class="separator:a781ae46ca99abb56b9e5d0a6bc4113ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bed827b7afc60d282879603a143db9"><td class="memItemLeft" align="right" valign="top"><a id="a58bed827b7afc60d282879603a143db9" name="a58bed827b7afc60d282879603a143db9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>traverseInOrder</b> (<a class="el" href="class_i_t_c_o_d_bsp_callback.html">ITCODBspCallback</a> *listener, void *userData)</td></tr>
<tr class="separator:a58bed827b7afc60d282879603a143db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21abddd6f490262784f7de5cb3a510a8"><td class="memItemLeft" align="right" valign="top"><a id="a21abddd6f490262784f7de5cb3a510a8" name="a21abddd6f490262784f7de5cb3a510a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>traversePostOrder</b> (<a class="el" href="class_i_t_c_o_d_bsp_callback.html">ITCODBspCallback</a> *listener, void *userData)</td></tr>
<tr class="separator:a21abddd6f490262784f7de5cb3a510a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550250f7e3085588e45dee6ce9b460d5"><td class="memItemLeft" align="right" valign="top"><a id="a550250f7e3085588e45dee6ce9b460d5" name="a550250f7e3085588e45dee6ce9b460d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>traverseLevelOrder</b> (<a class="el" href="class_i_t_c_o_d_bsp_callback.html">ITCODBspCallback</a> *listener, void *userData)</td></tr>
<tr class="separator:a550250f7e3085588e45dee6ce9b460d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee934272f087e8a180070f364da26f78"><td class="memItemLeft" align="right" valign="top"><a id="aee934272f087e8a180070f364da26f78" name="aee934272f087e8a180070f364da26f78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>traverseInvertedLevelOrder</b> (<a class="el" href="class_i_t_c_o_d_bsp_callback.html">ITCODBspCallback</a> *listener, void *userData)</td></tr>
<tr class="separator:aee934272f087e8a180070f364da26f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_t_c_o_d_tree"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_t_c_o_d_tree')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_t_c_o_d_tree.html">TCODTree</a></td></tr>
<tr class="memitem:a39910d70b0feacd33feb49a411ba9cb1 inherit pub_methods_class_t_c_o_d_tree"><td class="memItemLeft" align="right" valign="top"><a id="a39910d70b0feacd33feb49a411ba9cb1" name="a39910d70b0feacd33feb49a411ba9cb1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addSon</b> (<a class="el" href="class_t_c_o_d_tree.html">TCODTree</a> *data)</td></tr>
<tr class="separator:a39910d70b0feacd33feb49a411ba9cb1 inherit pub_methods_class_t_c_o_d_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae9c97e66e8b0f5bcfea5611fbd7af140"><td class="memItemLeft" align="right" valign="top"><a id="ae9c97e66e8b0f5bcfea5611fbd7af140" name="ae9c97e66e8b0f5bcfea5611fbd7af140"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>x</b></td></tr>
<tr class="separator:ae9c97e66e8b0f5bcfea5611fbd7af140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c81f4fa86426b77b1e5b9063146c9d6"><td class="memItemLeft" align="right" valign="top"><a id="a7c81f4fa86426b77b1e5b9063146c9d6" name="a7c81f4fa86426b77b1e5b9063146c9d6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>y</b></td></tr>
<tr class="separator:a7c81f4fa86426b77b1e5b9063146c9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777db464e7667e0fee51365b1e871ef4"><td class="memItemLeft" align="right" valign="top"><a id="a777db464e7667e0fee51365b1e871ef4" name="a777db464e7667e0fee51365b1e871ef4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>w</b></td></tr>
<tr class="separator:a777db464e7667e0fee51365b1e871ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0275f03b36eb66601868a8ba2890a11"><td class="memItemLeft" align="right" valign="top"><a id="ab0275f03b36eb66601868a8ba2890a11" name="ab0275f03b36eb66601868a8ba2890a11"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>h</b></td></tr>
<tr class="separator:ab0275f03b36eb66601868a8ba2890a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1811ca915ce0a5e4afa516c696367a95"><td class="memItemLeft" align="right" valign="top"><a id="a1811ca915ce0a5e4afa516c696367a95" name="a1811ca915ce0a5e4afa516c696367a95"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>position</b></td></tr>
<tr class="separator:a1811ca915ce0a5e4afa516c696367a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ede6b91d55dc94afbe69ddcccfa732"><td class="memItemLeft" align="right" valign="top"><a id="a32ede6b91d55dc94afbe69ddcccfa732" name="a32ede6b91d55dc94afbe69ddcccfa732"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>horizontal</b></td></tr>
<tr class="separator:a32ede6b91d55dc94afbe69ddcccfa732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b8411c67d843b6edf2383115661c2d"><td class="memItemLeft" align="right" valign="top"><a id="aa3b8411c67d843b6edf2383115661c2d" name="aa3b8411c67d843b6edf2383115661c2d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>level</b></td></tr>
<tr class="separator:aa3b8411c67d843b6edf2383115661c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_class_t_c_o_d_tree"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_t_c_o_d_tree')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_t_c_o_d_tree.html">TCODTree</a></td></tr>
<tr class="memitem:ae3335778c746157883c3dcf7a3058e0e inherit pub_attribs_class_t_c_o_d_tree"><td class="memItemLeft" align="right" valign="top"><a id="ae3335778c746157883c3dcf7a3058e0e" name="ae3335778c746157883c3dcf7a3058e0e"></a>
<a class="el" href="class_t_c_o_d_tree.html">TCODTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>next</b> = nullptr</td></tr>
<tr class="separator:ae3335778c746157883c3dcf7a3058e0e inherit pub_attribs_class_t_c_o_d_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed0b5ba34d53d6838c88cfcaa02d07e inherit pub_attribs_class_t_c_o_d_tree"><td class="memItemLeft" align="right" valign="top"><a id="afed0b5ba34d53d6838c88cfcaa02d07e" name="afed0b5ba34d53d6838c88cfcaa02d07e"></a>
<a class="el" href="class_t_c_o_d_tree.html">TCODTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>father</b> = nullptr</td></tr>
<tr class="separator:afed0b5ba34d53d6838c88cfcaa02d07e inherit pub_attribs_class_t_c_o_d_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390a124b8cc069a4c7c1c5dc00e7e870 inherit pub_attribs_class_t_c_o_d_tree"><td class="memItemLeft" align="right" valign="top"><a id="a390a124b8cc069a4c7c1c5dc00e7e870" name="a390a124b8cc069a4c7c1c5dc00e7e870"></a>
<a class="el" href="class_t_c_o_d_tree.html">TCODTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sons</b> = nullptr</td></tr>
<tr class="separator:a390a124b8cc069a4c7c1c5dc00e7e870 inherit pub_attribs_class_t_c_o_d_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae60d43370461de63b15e91a376e1e4ca"><td class="memItemLeft" align="right" valign="top"><a id="ae60d43370461de63b15e91a376e1e4ca" name="ae60d43370461de63b15e91a376e1e4ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TCODBsp</b> (<a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *father, bool left)</td></tr>
<tr class="separator:ae60d43370461de63b15e91a376e1e4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This toolkit allows one to create and manipulate 2D Binary Space Partition trees. They can be used to split a rectangular region into non overlapping sub-regions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3d9dd6efec6193d43067f3e054e39ab3" name="a3d9dd6efec6193d43067f3e054e39ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9dd6efec6193d43067f3e054e39ab3">&#9670;&#160;</a></span>TCODBsp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TCODBsp::TCODBsp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First, you have to create the root node of the tree. </p>
<p >This node encompasses the whole rectangular region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y,w,h</td><td>Top left corner position and size of the rectangular region covered by the BSP tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a620f60223047a5a1f36f976af90bc863" name="a620f60223047a5a1f36f976af90bc863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620f60223047a5a1f36f976af90bc863">&#9670;&#160;</a></span>~TCODBsp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TCODBsp::~TCODBsp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>You can also completely delete the tree, including the root node to release every resource used : </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the node reference.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *myBSP = new <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp(0,0,50,50)</a>; create a tree myBSP-&gt;splitRecursive(NULL,4,5,5,1.5f,1.5f); use the tree ... delete the tree delete myBSP;</p>
<p ><a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f); use the tree ... TCOD_bsp_delete(my_bsp);</p>
<p >my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) </p>
<h1><a class="anchor" id="autotoc_md2"></a>
use the tree ...</h1>
<p >libtcod.bsp_delete(my_bsp) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1360cc43a7d5cd21a0bcacbfa119f89" name="af1360cc43a7d5cd21a0bcacbfa119f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1360cc43a7d5cd21a0bcacbfa119f89">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCODBsp::contains </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can check if a map cell is inside a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the node reference. </td></tr>
    <tr><td class="paramname">cx,cy</td><td>Map cell coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25504bfc4750a5b3a1e9dd9cdb0e0b58" name="a25504bfc4750a5b3a1e9dd9cdb0e0b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25504bfc4750a5b3a1e9dd9cdb0e0b58">&#9670;&#160;</a></span>findNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> * TCODBsp::findNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can search the tree for the smallest node containing a map cell. </p>
<p >If the cell is outside the tree, the function returns NULL :</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the node reference. </td></tr>
    <tr><td class="paramname">cx,cy</td><td>Map cell coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a934a1ad8d407a365c93ecb21c4161f32" name="a934a1ad8d407a365c93ecb21c4161f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934a1ad8d407a365c93ecb21c4161f32">&#9670;&#160;</a></span>getLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> * TCODBsp::getLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Once you have built a BSP tree, you can retrieve information from any node. </p>
<p >The node gives you free access to its fields :</p>
<p >class <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> { public : int x,y,w,h; // int position; // position of splitting bool horizontal; // horizontal splitting ? uint8_t level; // level in the tree ... }</p>
<p >typedef struct { int x,y,w,h; int position; bool horizontal; uint8_t level; ... } <a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a>;</p>
<p >class <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> { public int x { get; set; } public int y { get; set; } public int h { get; set; } public int w { get; set; } public int position { get; set; } public bool horizontal { get; set; } public byte level { get; set; } } </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y,w,h</td><td>Rectangular region covered by this node. </td></tr>
    <tr><td class="paramname">position</td><td>If this node is not a leaf, splitting position. </td></tr>
    <tr><td class="paramname">horizontal</td><td>If this node is not a leaf, splitting orientation. </td></tr>
    <tr><td class="paramname">level</td><td>Level in the BSP tree (0 for the root, 1 for the root's sons, ...).</td></tr>
  </table>
  </dd>
</dl>
<p>You can navigate from a node to its sons or its parent using one of those functions. Each function returns NULL if the corresponding node does not exists (if the node is not split for getLeft and getRight, and if the node is the root node for getFather).</p>
<p ><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *TCODBsp<a class="el" href="class_t_c_o_d_bsp.html#a934a1ad8d407a365c93ecb21c4161f32" title="Once you have built a BSP tree, you can retrieve information from any node.">getLeft() const</a> <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *TCODBspgetRight() const <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *TCODBspgetFather() const</p>
<p ><a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> * TCOD_bsp_left(TCOD_bsp_t *node) <a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> * TCOD_bsp_right(TCOD_bsp_t *node) <a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> * TCOD_bsp_father(TCOD_bsp_t *node)</p>
<p >bsp_left(node) bsp_right(node) bsp_father(node)</p>
<p ><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> <a class="el" href="class_t_c_o_d_bsp.html#a934a1ad8d407a365c93ecb21c4161f32" title="Once you have built a BSP tree, you can retrieve information from any node.">TCODBsp::getLeft()</a> <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> TCODBsp::getRight() <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> TCODBsp::getFather() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the node reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8942e17837013284425a0616ae04ad76" name="a8942e17837013284425a0616ae04ad76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8942e17837013284425a0616ae04ad76">&#9670;&#160;</a></span>removeSons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCODBsp::removeSons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can delete a part of the tree, releasing resources for all sub nodes with : </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the node reference.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *myBSP = new <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp(0,0,50,50)</a>; create a tree myBSP-&gt;splitRecursive(NULL,4,5,5,1.5f,1.5f); clear it (keep only the root) myBSP-&gt;<a class="el" href="class_t_c_o_d_bsp.html#a8942e17837013284425a0616ae04ad76" title="You can delete a part of the tree, releasing resources for all sub nodes with :">removeSons()</a>; and rebuild another random tree myBSP-&gt;splitRecursive(NULL,4,5,5,1.5f,1.5f);</p>
<p ><a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f); TCOD_bsp_remove_sons(my_bsp); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);</p>
<p >my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) libtcod.bsp_remove_sons(my_bsp) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) </p>

</div>
</div>
<a id="a4e1a2884ecf106f784f98a4525c65f08" name="a4e1a2884ecf106f784f98a4525c65f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1a2884ecf106f784f98a4525c65f08">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCODBsp::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operation resets the size of the tree nodes without changing the splitting data (orientation/position). </p>
<p >It should be called with the initial region size or a bigger size, else some splitting position may be out of the region. You can use it if you changed the nodes size and position while using the BSP tree, which happens typically when you use the tree to build a dungeon. You create rooms inside the tree leafs, then shrink the leaf to fit the room size. Calling resize on the root node with the original region size allows you to reset all nodes to their original size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting. </td></tr>
    <tr><td class="paramname">x,y,w,h</td><td>New position and size of the node. The original rectangular area covered by the node should be included in the new one to ensure that every splitting edge stay inside its node.</td></tr>
  </table>
  </dd>
</dl>
<p>We create a BSP, do some processing that will modify the x,y,w,h fields of the tree nodes, then reset all the nodes to their original size. <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *myBSP = new <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp(0,0,50,50)</a>; myBSP-&gt;splitRecursive(NULL,4,5,5,1.5f,1.5f); ... do something with the tree here myBSP-&gt;resize(0,0,50,50);</p>
<p ><a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f); ... do something with the tree here TCOD_bsp_resize(my_bsp,0,0,50,50);</p>
<p >my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) </p>
<h1><a class="anchor" id="autotoc_md3"></a>
... do something with the tree here</h1>
<p >libtcod.bsp_resize(my_bsp,0,0,50,50) </p>

</div>
</div>
<a id="a6b6221bf79a1d0aa2275fa2e04b751b1" name="a6b6221bf79a1d0aa2275fa2e04b751b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6221bf79a1d0aa2275fa2e04b751b1">&#9670;&#160;</a></span>splitOnce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCODBsp::splitOnce </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>horizontal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once you have the root node, you can split it into two smaller non-overlapping nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting. </td></tr>
    <tr><td class="paramname">horizontal</td><td>If true, the node will be split horizontally, else, vertically. </td></tr>
    <tr><td class="paramname">position</td><td>Coordinate of the splitting position. If horizontal is true, x &lt;= position &lt; x+w Else, y &lt;= position &lt; y+h</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *myBSP = new <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp(0,0,50,50)</a>; myBSP-&gt;splitOnce(true,20); // horizontal split into two nodes : (0,0,50,20) and (0,20,50,30)</p>
<p ><a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_once(my_bsp,false,20); // vertical split into two nodes : (0,0,20,50) and (20,0,30,50)</p>
<p >my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_once(my_bsp,False,20) # vertical split into two nodes : (0,0,20,50) and (20,0,30,50) </p>

</div>
</div>
<a id="ac45a60808aa2f17d138cb10744b65ab2" name="ac45a60808aa2f17d138cb10744b65ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45a60808aa2f17d138cb10744b65ab2">&#9670;&#160;</a></span>splitRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCODBsp::splitRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_c_o_d_random.html">TCODRandom</a> *&#160;</td>
          <td class="paramname"><em>randomizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minHSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minVSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxHRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxVRatio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can also recursively split the bsp. </p>
<p >At each step, a random orientation (horizontal/vertical) and position are chosen :</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting. </td></tr>
    <tr><td class="paramname">randomizer</td><td>The random number generator to use. Use NULL for the default one. </td></tr>
    <tr><td class="paramname">nb</td><td>Number of recursion levels. </td></tr>
    <tr><td class="paramname">minHSize,minVSize</td><td>minimum values of w and h for a node. A node is split only if the resulting sub-nodes are bigger than minHSize x minVSize </td></tr>
    <tr><td class="paramname">maxHRatio,maxVRation</td><td>maximum values of w/h and h/w for a node. If a node does not conform, the splitting orientation is forced to reduce either the w/h or the h/w ratio. Use values near 1.0 to promote square nodes.</td></tr>
  </table>
  </dd>
</dl>
<p>Do a 4 levels BSP tree (the region is split into a maximum of 2*2*2*2 sub-regions). <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a> *myBSP = new <a class="el" href="class_t_c_o_d_bsp.html">TCODBsp(0,0,50,50)</a>; myBSP-&gt;splitRecursive(NULL,4,5,5,1.5f,1.5f);</p>
<p ><a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> *my_bsp=TCOD_bsp_new_with_size(0,0,50,50); TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);</p>
<p >my_bsp=libtcod.bsp_new_with_size(0,0,50,50) libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5) </p>

</div>
</div>
<a id="a781ae46ca99abb56b9e5d0a6bc4113ca" name="a781ae46ca99abb56b9e5d0a6bc4113ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781ae46ca99abb56b9e5d0a6bc4113ca">&#9670;&#160;</a></span>traversePreOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCODBsp::traversePreOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_t_c_o_d_bsp_callback.html">ITCODBspCallback</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can scan all the nodes of the tree and have a custom function called back for each node. </p>
<p >Each traversal function returns false if the traversal has been interrupted (a callback returned false). Pre-order : the callback is called for the current node, then for the left son, then for the right son. In-order : the callback is called for the left son, then for current node, then for the right son. Post-order : the callback is called for the left son, then for the right son, then for the current node. Level-order : the callback is called for the nodes level by level, from left to right. Inverted level-order : the callback is called in the exact inverse order as Level-order. </p><table class="param">
</table>
<p >Pre order</p>
<p >In order</p>
<p >Post order</p>
<p >Level order</p>
<p >Inverted level<br  />
order </p>
<p ><img src="bsp_preorder.png" alt="" class="inline"/></p>
<p ><img src="bsp_inorder.png" alt="" class="inline"/></p>
<p ><img src="bsp_postorder.png" alt="" class="inline"/></p>
<p ><img src="bsp_levelorder.png" alt="" class="inline"/></p>
<p ><img src="bsp_invlevelorder.png" alt="" class="inline"/> &lt;/tbody&gt;</p>
<p >class <a class="el" href="class_i_t_c_o_d_bsp_callback.html">ITCODBspCallback</a> { public : virtual bool visitNode(TCODBsp *node, void *userData) = 0; };</p>
<p >bool <a class="el" href="class_t_c_o_d_bsp.html#a781ae46ca99abb56b9e5d0a6bc4113ca" title="You can scan all the nodes of the tree and have a custom function called back for each node.">TCODBsp::traversePreOrder(ITCODBspCallback *callback, void *userData)</a> bool TCODBsp::traverseInOrder(ITCODBspCallback *callback, void *userData) bool TCODBsp::traversePostOrder(ITCODBspCallback *callback, void *userData) bool TCODBsp::traverseLevelOrder(ITCODBspCallback *callback, void *userData) bool TCODBsp::traverseInvertedLevelOrder(ITCODBspCallback *callback, void *userData)</p>
<p >typedef bool (*TCOD_bsp_callback_t)(<a class="el" href="struct_t_c_o_d__bsp__t.html">TCOD_bsp_t</a> *node, void *userData)</p>
<p >bool TCOD_bsp_traverse_pre_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData) bool TCOD_bsp_traverse_in_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData) bool TCOD_bsp_traverse_post_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData) bool TCOD_bsp_traverse_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData) bool TCOD_bsp_traverse_inverted_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)</p>
<p >def bsp_callback(node, userData) : # ...</p>
<p >bsp_traverse_pre_order(node, callback, userData=0) bsp_traverse_in_order(node, callback, userData=0) bsp_traverse_post_order(node, callback, userData=0) bsp_traverse_level_order(node, callback, userData=0) bsp_traverse_inverted_level_order(node, callback, userData=0)</p>
<p >bool TCODBsp::traversePreOrder(ITCODBspCallback callback) bool TCODBsp::traverseInOrder(ITCODBspCallback callback) bool TCODBsp::traversePostOrder(ITCODBspCallback callback) bool TCODBsp::traverseLevelOrder(ITCODBspCallback callback) bool TCODBsp::traverseInvertedLevelOrder(ITCODBspCallback callback) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>In the C version, the node reference (generally, the root node). </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call for each node. It receives the current node and the custom data as parameters If it returns false, the traversal is interrupted. </td></tr>
    <tr><td class="paramname">userData</td><td>Custom data to pass to the callback.</td></tr>
  </table>
  </dd>
</dl>
<p>class MyCallback : public <a class="el" href="class_i_t_c_o_d_bsp_callback.html">ITCODBspCallback</a> { public : bool visitNode(TCODBsp *node, void *userData) { printf("node pos %dx%d size %dx%d level %d\n",node-&gt;x,node-&gt;y,node-&gt;w,node-&gt;h,node-&gt;level); return true; } }; myBSP-&gt;traversePostOrder(new MyListener(),NULL);</p>
<p >bool my_callback(TCOD_bsp_t *node, void *userData) { printf("node pos %dx%d size %dx%d level %d\n",node-&gt;x,node-&gt;y,node-&gt;w,node-&gt;h,node-&gt;level); return true; } TCOD_bsp_traverse_post_order(my_bsp,my_callback,NULL);</p>
<p >def my_callback(node, userData) : print "node pos %dx%d size %dx%d level %d"%(node.x,node.y,node.w,node.h,node.level)) return True libtcod.bsp_traverse_post_order(my_bsp,my_callback) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/4b796/Projects/libtcod/src/libtcod/<a class="el" href="bsp_8hpp_source.html">bsp.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_c_o_d_bsp.html">TCODBsp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
