<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-772NXFFJ4E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-772NXFFJ4E');
  </script>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>libtcod: ITCODParserListener Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
  </script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">libtcod
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_i_t_c_o_d_parser_listener.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_t_c_o_d_parser_listener-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ITCODParserListener Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>For basic config files, you don't have to write a listener.  
 <a href="class_i_t_c_o_d_parser_listener.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="parser_8hpp_source.html">parser.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa1f698a183acaa15a38614b0221f3be9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_t_c_o_d_parser_listener.html#aa1f698a183acaa15a38614b0221f3be9">parserNewStruct</a> (<a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> *parser, const <a class="el" href="class_t_c_o_d_parser_struct.html">TCODParserStruct</a> *str, const char *name)=0</td></tr>
<tr class="memdesc:aa1f698a183acaa15a38614b0221f3be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called each time the parser find a new structure declaration in the file.  <a href="class_i_t_c_o_d_parser_listener.html#aa1f698a183acaa15a38614b0221f3be9">More...</a><br /></td></tr>
<tr class="separator:aa1f698a183acaa15a38614b0221f3be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af974dd420ac692997810a770e95a647c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_t_c_o_d_parser_listener.html#af974dd420ac692997810a770e95a647c">parserFlag</a> (<a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> *parser, const char *name)=0</td></tr>
<tr class="memdesc:af974dd420ac692997810a770e95a647c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called each time the parser find a new flag in the file.  <a href="class_i_t_c_o_d_parser_listener.html#af974dd420ac692997810a770e95a647c">More...</a><br /></td></tr>
<tr class="separator:af974dd420ac692997810a770e95a647c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774fd145d75d15179b50539138ec2073"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_t_c_o_d_parser_listener.html#a774fd145d75d15179b50539138ec2073">parserProperty</a> (<a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> *parser, const char *propname, TCOD_value_type_t type, <a class="el" href="union_t_c_o_d__value__t.html">TCOD_value_t</a> value)=0</td></tr>
<tr class="memdesc:a774fd145d75d15179b50539138ec2073"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called each time the parser find a new property in the file.  <a href="class_i_t_c_o_d_parser_listener.html#a774fd145d75d15179b50539138ec2073">More...</a><br /></td></tr>
<tr class="separator:a774fd145d75d15179b50539138ec2073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346a06c2e438958bf8be5a4cb5c2a770"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_t_c_o_d_parser_listener.html#a346a06c2e438958bf8be5a4cb5c2a770">parserEndStruct</a> (<a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> *parser, const <a class="el" href="class_t_c_o_d_parser_struct.html">TCODParserStruct</a> *str, const char *name)=0</td></tr>
<tr class="memdesc:a346a06c2e438958bf8be5a4cb5c2a770"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called each time the parser find the end of a structure declaration in the file.  <a href="class_i_t_c_o_d_parser_listener.html#a346a06c2e438958bf8be5a4cb5c2a770">More...</a><br /></td></tr>
<tr class="separator:a346a06c2e438958bf8be5a4cb5c2a770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81eca4f32c9411d5b82405f261f9c95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_t_c_o_d_parser_listener.html#ad81eca4f32c9411d5b82405f261f9c95">error</a> (const char *msg)=0</td></tr>
<tr class="memdesc:ad81eca4f32c9411d5b82405f261f9c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are two kind of errors : Errors that are detected by the parser itself (malformed file, bad value syntax for a property, missing mandatory property in a structure, ...).  <a href="class_i_t_c_o_d_parser_listener.html#ad81eca4f32c9411d5b82405f261f9c95">More...</a><br /></td></tr>
<tr class="separator:ad81eca4f32c9411d5b82405f261f9c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >For basic config files, you don't have to write a listener. </p>
<p >Instead, use the default listener. The parser uses a SAX-like approach during the parsing of the file. This means that the whole file is not stored in memory in a tree structure. Instead, it works like a stream parser and raises events. Each event has an associated callback that is provided by a listener :</p>
<p >class <a class="el" href="class_i_t_c_o_d_parser_listener.html" title="For basic config files, you don&#39;t have to write a listener.">ITCODParserListener</a> { public : virtual bool <a class="el" href="class_i_t_c_o_d_parser_listener.html#aa1f698a183acaa15a38614b0221f3be9" title="This callback is called each time the parser find a new structure declaration in the file.">parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)</a>=0; virtual bool <a class="el" href="class_i_t_c_o_d_parser_listener.html#af974dd420ac692997810a770e95a647c" title="This callback is called each time the parser find a new flag in the file.">parserFlag(TCODParser *parser,const char *name)</a>=0; virtual bool <a class="el" href="class_i_t_c_o_d_parser_listener.html#a774fd145d75d15179b50539138ec2073" title="This callback is called each time the parser find a new property in the file.">parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)</a>=0; virtual bool <a class="el" href="class_i_t_c_o_d_parser_listener.html#a346a06c2e438958bf8be5a4cb5c2a770" title="This callback is called each time the parser find the end of a structure declaration in the file.">parserEndStruct(TCODParser *parser,const TCODParserStruct *str, const char *name)</a>=0; virtual void <a class="el" href="class_i_t_c_o_d_parser_listener.html#ad81eca4f32c9411d5b82405f261f9c95" title="There are two kind of errors : Errors that are detected by the parser itself (malformed file,...">error(const char *msg)</a> = 0; };</p>
<p >typedef struct { bool (*new_struct)(TCOD_parser_struct_t str,const char *name); bool (*new_flag)(const char *name); bool (*new_property)(const char *name, TCOD_value_type_t type, <a class="el" href="union_t_c_o_d__value__t.html">TCOD_value_t</a> value); bool (*end_struct)(TCOD_parser_struct_t str, const char *name); void (*error)(const char *msg); } <a class="el" href="struct_t_c_o_d__parser__listener__t.html">TCOD_parser_listener_t</a>;</p>
<p >class ParserListener : def new_struct(str,name) : ... def new_flag(name) : ... def new_property(name,type,value) : ... def end_struct(self, struct, name) : ... def error(msg) : ...</p>
<p >Before running the parser, you have to build a listener :</p>
<p >class MyListener : public <a class="el" href="class_i_t_c_o_d_parser_listener.html" title="For basic config files, you don&#39;t have to write a listener.">ITCODParserListener</a> { bool <a class="el" href="class_i_t_c_o_d_parser_listener.html#aa1f698a183acaa15a38614b0221f3be9" title="This callback is called each time the parser find a new structure declaration in the file.">parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)</a> { printf ("new structure type '%s' with name '%s'\n",str-&gt;getname(),name ? name : "NULL"); return true; } bool <a class="el" href="class_i_t_c_o_d_parser_listener.html#af974dd420ac692997810a770e95a647c" title="This callback is called each time the parser find a new flag in the file.">parserFlag(TCODParser *parser,const char *name)</a> { printf ("found new flag '%s'\n",name); return true; } bool <a class="el" href="class_i_t_c_o_d_parser_listener.html#a774fd145d75d15179b50539138ec2073" title="This callback is called each time the parser find a new property in the file.">parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)</a> { printf ("found new property '%s'\n",name); return true; } bool <a class="el" href="class_i_t_c_o_d_parser_listener.html#a346a06c2e438958bf8be5a4cb5c2a770" title="This callback is called each time the parser find the end of a structure declaration in the file.">parserEndStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)</a> { printf ("end of structure type '%s'\n",name); return true; } void error(char *msg) { fprintf(stderr,msg); exit(1); } };</p>
<p >bool my_parser_new_struct(TCOD_parser_struct_t str, const char *name) { printf ("new structure type '%s' with name '%s'\n",TCOD_struct_get_name(str),name ? name : "NULL"); return true; } bool my_parser_flag(const char *name) { printf ("found new flag '%s'\n",name); return true; } bool my_parser_property(const char *name, TCOD_value_type_t type, TCOD_value_t value) { printf ("found new property '%s'\n",name); return true; } bool my_parser_end_struct(TCOD_parser_struct_t str, const char *name) { printf ("end of structure type '%s'\n",name); return true; } void my_parser_error(const char *msg) { fprintf(stderr,msg); exit(1); } <a class="el" href="struct_t_c_o_d__parser__listener__t.html">TCOD_parser_listener_t</a> my_listener = { my_parser_new_struct, my_parser_flag, my_parser_property, my_parser_end_struct, my_parser_error };</p>
<p >class MyListener: def new_struct(self, struct, name): print 'new structure type', libtcod.struct_get_name(struct), ' named ', name return True def new_flag(self, name): print 'new flag named ', name return True def new_property(self,name, typ, value): type_names = ['NONE', 'BOOL', 'CHAR', 'INT', 'FLOAT', 'STRING', 'COLOR', 'DICE'] if typ == libtcod.TYPE_COLOR : print 'new property named ', name,' type ',type_names[typ], ' value ', value.r, value.g, value.b elif typ == libtcod.TYPE_DICE : print 'new property named ', name,' type ',type_names[typ], ' value ', value.nb_rolls, value.nb_faces, value.multiplier, value.addsub else: print 'new property named ', name,' type ',type_names[typ], ' value ', value return True def end_struct(self, struct, name): print 'end structure type', libtcod.struct_get_name(struct), ' named ', name return True def error(self,msg): print 'error : ', msg return True </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad81eca4f32c9411d5b82405f261f9c95" name="ad81eca4f32c9411d5b82405f261f9c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81eca4f32c9411d5b82405f261f9c95">&#9670;&#160;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ITCODParserListener::error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There are two kind of errors : Errors that are detected by the parser itself (malformed file, bad value syntax for a property, missing mandatory property in a structure, ...). </p>
<p >Errors that you detect in your callbacks. When the parser finds an error in the file, it will call the error callback and stop :</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The error message from the parser with the file name and the line number.</td></tr>
  </table>
  </dd>
</dl>
<p>If you find an error in your callback, you have to call the parser error function. It will add the file name and line number to your error message, and then call your error callback : The code in the example below will result in your error callback called with the following string : "error in &amp;lt;filename&amp;gt; line &amp;lt;line_number&amp;gt; : Bad cost value %d. Cost must be between 0 and 1000"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>printf-like format string for your error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a346a06c2e438958bf8be5a4cb5c2a770" name="a346a06c2e438958bf8be5a4cb5c2a770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346a06c2e438958bf8be5a4cb5c2a770">&#9670;&#160;</a></span>parserEndStruct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ITCODParserListener::parserEndStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_c_o_d_parser_struct.html">TCODParserStruct</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This callback is called each time the parser find the end of a structure declaration in the file. </p>
<p >Example : </p><div class="code"><pre>item_type "blade" {
  ...
} // &lt;= endStruct event here
</pre></div><p> It must return true if everything is right, false if there is an error and the parser must exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>In the C++ version, the parser object, returned by <a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> constructor. It's used for error handling. </td></tr>
    <tr><td class="paramname">str</td><td>The structure type. Can be used to retrieve the type's name with getName. In the example above, this would be "item_type". </td></tr>
    <tr><td class="paramname">name</td><td>The name of the structure or NULL if no name is present in the file. In the example above, this would be "blade". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af974dd420ac692997810a770e95a647c" name="af974dd420ac692997810a770e95a647c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af974dd420ac692997810a770e95a647c">&#9670;&#160;</a></span>parserFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ITCODParserListener::parserFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This callback is called each time the parser find a new flag in the file. </p>
<p >Example : </p><div class="code"><pre>item_type "blade" {
  abstract  // &lt;= newFlag event here
}
</pre></div><p> It must return true if everything is right, false if there is an error and the parser must exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>In the C++ version, the parser object, returned by <a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> constructor. It's used for error handling. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the flag. In the example, this would be "abstract". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1f698a183acaa15a38614b0221f3be9" name="aa1f698a183acaa15a38614b0221f3be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f698a183acaa15a38614b0221f3be9">&#9670;&#160;</a></span>parserNewStruct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ITCODParserListener::parserNewStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_c_o_d_parser_struct.html">TCODParserStruct</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This callback is called each time the parser find a new structure declaration in the file. </p>
<p >Example : </p><div class="code"><pre>item_type "blade" { // &lt;= newStruct event here
  ...
}
</pre></div><p> It must return true if everything is right, false if there is an error and the parser must exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>In the C++ version, the parser object, returned by <a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> constructor. It's used for error handling. </td></tr>
    <tr><td class="paramname">str</td><td>The structure type. Can be used to retrieve the type's name with getName. In the example above, this would be "item_type". </td></tr>
    <tr><td class="paramname">name</td><td>The name of the structure or NULL if no name is present in the file. In the example above, this would be "blade". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a774fd145d75d15179b50539138ec2073" name="a774fd145d75d15179b50539138ec2073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774fd145d75d15179b50539138ec2073">&#9670;&#160;</a></span>parserProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ITCODParserListener::parserProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCOD_value_type_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_t_c_o_d__value__t.html">TCOD_value_t</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This callback is called each time the parser find a new property in the file. </p>
<p >Example : </p><div class="code"><pre>item_type "blade" {
  abstract
  cost=300 // &lt;= newProperty event here
}
</pre></div><p> It must return true if everything is right, false if there is an error and the parser must exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>In the C++ version, the parser object, returned by <a class="el" href="class_t_c_o_d_parser.html">TCODParser</a> constructor. It's used for error handling. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property. In the example, this would be "cost". </td></tr>
    <tr><td class="paramname">type</td><td>The type of the property as defined when you called addProperty or addValueList. In the example, this would be TCOD_TYPE_INT. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the property, stored in a generic value structure. In the example, we would have value.i == 300. In the case of a value-list property, the type would reflect the list id (between TCOD_TYPE_VALUELIST00 and TCOD_TYPE_VALUELIST15) and value.s would contain the actual string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/4b796/Projects/libtcod/src/libtcod/<a class="el" href="parser_8hpp_source.html">parser.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_i_t_c_o_d_parser_listener.html">ITCODParserListener</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
